# 2022-03-10

## 컴퓨터 시스템 조직

<img width="607" alt="스크린샷 2022-03-19 오후 7 09 36" src="https://user-images.githubusercontent.com/67616146/159116891-5128155d-d0bd-458e-a084-3af445b214b6.png">

현대 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 엑세스를 제공하는 데이터 버스를 통해 연결된 여러 제어 장치들로 구성된다.

<br/>

<img width="308" alt="스크린샷 2022-03-19 오후 7 41 41" src="https://user-images.githubusercontent.com/67616146/159117785-7a6a03ce-a21f-45c5-b4ab-68b028f1d0a4.png">

<br/>

운영체제는 물리적인 장치가 무엇인지 상관하지 않지만 논리적인 장치에서 컨트롤러를 바라본다.
컨트롤러는 물리적인 장치와 운영체제를 연결해준다. 물리적 장치에서 입력된 문자를 버퍼에 저장했다가 운영체제에게 전달해 줌으로써 사용자가 입력한 값을 화면에 보여주는 역할이다.

<br/>

### 로컬 버퍼를 사용하는 이유

버퍼는 A, B가 직접 통신하는 것이 아니라 서로 통신할 수 있도록 정보를 임시로 저장할 수 있는 공간이다. A, B의 처리 속도가 다를 때 유용한데 잠시 저장해 두었다가 나중에 보거나 빨리 볼 수 있기 때문이다.<br/><br/>

## Interrupt Handling

운영체제가 디바이스 컨트롤러러부터 데이터를 읽어오는 방식은 두 가지가 있다.

- 폴링 - 택배가 왔는지 계속 나가보면서 확인<br/>
  운영체제가 자신이 할 일을 하면서 디바이스 컨트롤러에 있는 버퍼를 하나하나 살펴보는 것이다.

- 인터럽트 - 택배가 도착하면 문자를 보내줘서 즉시 확인 가능<br/>
  디바이스 컨트롤러가 운영체제에게 처리해야 하는 데이터가 있다고 알리는 것이다. 이것은 여러 프로세스나 하드웨어가 동시에 실행될 때, 서로 신호를 주고 받아서 실행 시간을 빠르게 하기 위해 사용된다.<br/>
  HDD가 RAM에 적재할 때, 일이 끝나면 버퍼를 1로 바꿔서 CPU가 작업이 끝난 것을 알 수 있도록 한다.

<br/>

<img width="736" alt="스크린샷 2022-03-20 오전 11 20 51" src="https://user-images.githubusercontent.com/67616146/159145224-d2b56489-1037-4497-81ca-4fb06b6996c0.png">

<br/>

인터럽트가 문제제기라면 인터럽트 서비스 루틴은 운영체제가 그 문제를 해결하는 것이다.<br/>
인터럽트가 발생하면 이것을 해결하기 위한 서비스 루틴을 가져야 한다. 이들의 주소를 가지고 있는 것이 인터럽트 벡터이다. 이런 운영체제를 interrupt driven 방식의 운영체제라고 한다.<br/>
interrupt driven 방식이 아니라면 인터럽트 발생시 운영체제가 바쁜 와중에도 계속해서 인터럽트를 확인하는 것이다.

<br/>

> 인터럽트 벡터(영어: interrupt vector)는 인터럽트가 발생했을 때, 그 인터럽트를 처리할 수 있는 서비스 루틴들의 주소를 가지고 있는 공간이다.

<br/>

## Paging(페이징)

<img width="638" alt="스크린샷 2022-03-14 오후 9 16 07" src="https://user-images.githubusercontent.com/67616146/158170335-d0cddafe-54d9-4bdc-b3dc-068142313bd0.png">

<br/>

HDD 일부 영역을 잘라서 RAM에 올린다.
그리고 RAM에 올린 명령이 끝날 것 같으면 다음 HDD 일부 영역을 RAM에 올란다.

<br/>

## RAM이 작아질수록 속도가 낮아지는 이유

RAM에 넣을 수 있는 명령어 수가 감소해서 페이징을 잘게 쪼개야 하기 때문이다.

<br/>

## 운영체제가 사용자 레벨 프로그램의 순서를 결정하는 이유

<img width="386" alt="스크린샷 2022-03-15 오전 11 03 31" src="https://user-images.githubusercontent.com/67616146/158291284-add4adf0-a3e8-4921-a6a2-316007868aa5.png">

<br/>

사용자 레벨보다 시스템 레벨이 더 우선이기 때문이다.<br/>
시스템 자원 개수는 한정적인데 응용 프로그램은 많아서 운영체제가 교통정리를 한다. (사용자 편의를 위해 시스템을 구동하기 위한 행동들을 운영체제가 한다)

<br/>

### 알아두기

- 사용자가 실행하는 프로그램은 반드시 RAM 내에 존재해야 한다.

- 운영체제는 반드시 RAM에 적재되어야 한다.

- 여러 프로세스가 자원을 공유할 때, 한 프로세스만 자원에 읽거나 쓸 수 있다.

- 디바이스 컨트롤러는 로컬 버퍼를 다 가지고 있다.

- I/O device와 CPU는 동시에 동작한다.
