# 2022-03-17

## RAM

<img width="183" alt="스크린샷 2022-03-20 오후 12 40 27" src="https://user-images.githubusercontent.com/67616146/159147054-c4c94a1a-6c87-4848-8700-ee00dff827cc.png">
<br/>
<br/>

RAM은 Random Access Memory로서 어디에 저장하나 읽어들이는 속도가 같은 메모리이다. HDD와는 다르다. 휘발성 메모리이다.

## 저장장치 계층구조

<img width="811" alt="스크린샷 2022-03-20 오후 12 58 33" src="https://user-images.githubusercontent.com/67616146/159147483-e0c66ce7-a490-46c0-81b2-f6ea07bde58d.png">

<br/>
<br/>
registers ~ main memory 는 1차 저장장치, nonvolatile memory ~ hard-disk drivers 는 2차 저장장치, optical disk ~ magnetic tapes는 3차 저장장치라고 한다. <br/>
위로 갈수록 가격이 비싸지고 엑세스 시간이 빨라진다.
<br/>
<br/>

## Direct Memory Access

<img width="322" alt="스크린샷 2022-03-20 오후 1 27 48" src="https://user-images.githubusercontent.com/67616146/159148188-61f1f8b0-9041-431a-8ab7-1e9f80bd0ce9.png">

<br/>
<br/>
byte 단위로 인터럽트 없이 읽어오지 않고 block 단위로 읽어와서 CPU 개입 없이 읽을 수 있다.

## Clcok speed에 대한 잘못된 생각

예전에는 clock speed가 빨라지면 CPU 속도가 올라간다고 알고 있었다.
하지만 클럭 수가 빨리질수록 오류가 많아진다. 전기적 신호를 읽는 시점도 짧아지고 전기적 신호도 사실 직각으로 딱딱 올라가지 않고 스무스하게 곡선으로 오르락내리락 하기 때문에 위의 그림처럼 어디서 읽는지 애매해진다. <br/><br/>
그래서 CPU 안에 코어를 여러 개 넣어서 성능을 올린다.
A라는 작업을 코어의 개수만큼 쪼개서 넣어야하는데 공정하게 쪼개지 못하는 경우는 일부 코어에서만 일하고 다른 코어에서는 일하지 않는 경우가 있다. 그리고 발열 문제 등 다른 문제들이 아직 남아있다.

## 멀티 프로세스

예전에는 마더 보드에 CPU 를 여러개 넣었다. 문제는 CPU 가 하나의 메모리를 접근하기 때문에 병목 현상이 발생한다. 그래서 CPU 마다 메모리를 나눈다.
이것의 단점은 CPU 에서 멀리 떨어진 메모리를 읽는데 시간이 오래 걸리 수 있는 것이다.

## Clustered Systems

<img width="570" alt="스크린샷 2022-03-20 오후 2 11 05" src="https://user-images.githubusercontent.com/67616146/159149151-7221c5c3-247e-44b8-a03a-b29c65698f87.png">

이는 컴퓨터들을 연결한 시스템이다. storage area network 를 통해서 컴퓨터들이 작업을 공유하고 컴퓨터들은 공유된 작업을 실제로 실행한다.
멀티 프로세스나 멀티 코어와 달리 컴퓨터가 죽어도 동작을 한다는 장점을 가진다.
